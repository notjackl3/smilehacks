const fs = require('fs');
const path = require('path');

// Read the OBJ file
const objPath = path.join(__dirname, '../public/models/jaw.obj');
const objContent = fs.readFileSync(objPath, 'utf-8');
const lines = objContent.split('\n');

// Parse vertices and faces
const vertices = [];
const normals = [];
const texCoords = [];
const faces = [];

lines.forEach(line => {
  const parts = line.trim().split(/\s+/);
  if (parts[0] === 'v') {
    vertices.push({
      x: parseFloat(parts[1]),
      y: parseFloat(parts[2]),
      z: parseFloat(parts[3])
    });
  } else if (parts[0] === 'vn') {
    normals.push({
      x: parseFloat(parts[1]),
      y: parseFloat(parts[2]),
      z: parseFloat(parts[3])
    });
  } else if (parts[0] === 'vt') {
    texCoords.push({
      u: parseFloat(parts[1]),
      v: parseFloat(parts[2])
    });
  } else if (parts[0] === 'f') {
    const faceVerts = parts.slice(1).map(p => {
      const indices = p.split('/');
      return {
        v: parseInt(indices[0]) - 1,
        vt: indices[1] ? parseInt(indices[1]) - 1 : null,
        vn: indices[2] ? parseInt(indices[2]) - 1 : null
      };
    });
    faces.push(faceVerts);
  }
});

console.log(`Parsed: ${vertices.length} vertices, ${faces.length} faces`);

// Union-Find for connected components
class UnionFind {
  constructor(n) {
    this.parent = Array.from({ length: n }, (_, i) => i);
    this.rank = new Array(n).fill(0);
  }

  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]);
    }
    return this.parent[x];
  }

  union(x, y) {
    const px = this.find(x);
    const py = this.find(y);
    if (px === py) return;
    if (this.rank[px] < this.rank[py]) {
      this.parent[px] = py;
    } else if (this.rank[px] > this.rank[py]) {
      this.parent[py] = px;
    } else {
      this.parent[py] = px;
      this.rank[px]++;
    }
  }
}

// Find connected components
const uf = new UnionFind(vertices.length);

faces.forEach(face => {
  for (let i = 1; i < face.length; i++) {
    uf.union(face[0].v, face[i].v);
  }
});

// Group faces by component
const faceComponents = faces.map((face, idx) => ({
  face,
  idx,
  component: uf.find(face[0].v)
}));

// Group by component
const componentFaces = new Map();
faceComponents.forEach(({ face, idx, component }) => {
  if (!componentFaces.has(component)) {
    componentFaces.set(component, []);
  }
  componentFaces.get(component).push({ face, idx });
});

console.log(`Found ${componentFaces.size} connected components`);

// Calculate center of each component for naming
const componentInfo = [];
componentFaces.forEach((faceList, component) => {
  let sumX = 0, sumY = 0, sumZ = 0, count = 0;

  faceList.forEach(({ face }) => {
    face.forEach(f => {
      sumX += vertices[f.v].x;
      sumY += vertices[f.v].y;
      sumZ += vertices[f.v].z;
      count++;
    });
  });

  componentInfo.push({
    component,
    faces: faceList,
    centerX: sumX / count,
    centerY: sumY / count,
    centerZ: sumZ / count,
    faceCount: faceList.length
  });
});

// Sort components by position (left to right, then front to back)
componentInfo.sort((a, b) => {
  // Sort primarily by X (left to right)
  return a.centerX - b.centerX;
});

// Name components based on size and position
// Large components are likely gums, small ones are teeth
componentInfo.forEach((info, idx) => {
  if (info.faceCount > 100) {
    info.name = `gum_${idx}`;
    info.type = 'gum';
  } else {
    // Teeth - name by position
    const side = info.centerX < 0 ? 'left' : 'right';
    const position = info.centerZ > 3 ? 'front' : info.centerZ > 0 ? 'middle' : 'back';
    info.name = `tooth_${side}_${position}_${idx}`;
    info.type = 'tooth';
  }
});

// Print component info
console.log('\nComponents:');
componentInfo.forEach(info => {
  console.log(`  ${info.name}: ${info.faceCount} faces (center: ${info.centerX.toFixed(1)}, ${info.centerY.toFixed(1)}, ${info.centerZ.toFixed(1)})`);
});

// Write new OBJ file with separate groups
let output = '# Segmented dental model\n';
output += '# Auto-generated by segment-teeth.js\n';
output += `# ${componentInfo.length} separate parts\n\n`;

// Write all vertices
vertices.forEach(v => {
  output += `v ${v.x} ${v.y} ${v.z}\n`;
});
output += '\n';

// Write all texture coordinates
texCoords.forEach(vt => {
  output += `vt ${vt.u} ${vt.v}\n`;
});
output += '\n';

// Write all normals
normals.forEach(vn => {
  output += `vn ${vn.x} ${vn.y} ${vn.z}\n`;
});
output += '\n';

// Write faces grouped by component
componentInfo.forEach(info => {
  output += `g ${info.name}\n`;
  output += `o ${info.name}\n`;

  info.faces.forEach(({ face }) => {
    const faceStr = face.map(f => {
      const parts = [(f.v + 1)];
      if (f.vt !== null) parts.push(f.vt + 1);
      else parts.push('');
      if (f.vn !== null) parts.push(f.vn + 1);
      return parts.join('/');
    }).join(' ');
    output += `f ${faceStr}\n`;
  });
  output += '\n';
});

// Write segmented model
const outputPath = path.join(__dirname, '../public/models/jaw-segmented.obj');
fs.writeFileSync(outputPath, output);
console.log(`\nWritten segmented model to: ${outputPath}`);

// Count teeth vs gums
const teeth = componentInfo.filter(c => c.type === 'tooth');
const gums = componentInfo.filter(c => c.type === 'gum');
console.log(`\nSummary: ${teeth.length} teeth, ${gums.length} gum sections`);
